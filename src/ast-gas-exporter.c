#ifndef _AST_STACKODE_EXPORTER_C_
#define _AST_STACKODE_EXPORTER_C_

#include <stdio.h>
#include "ast-gas-exporter.h"
#include "stackode.h"

void ast_export_root(FILE* dest, struct ast_node_t* root) {
#if !(defined(__x86_64__) && __x86_64__)
	fprintf(stderr, "aer: Warning: The compiler is designed to x86_64 platform. Generated assembly should not work to you.\n");
#endif

	sk_program_t* sk = ast_to_stackode(root);
	export_stackode_to_gas(dest, sk);
}

void export_stackode_to_gas(FILE* dest, sk_program_t* program) {
	int i;
	GAS_LOG("exporting %d instructions", program->count);

	export_gas_preamble(dest);

	for (i = 0; i < program->count; i++) {
		sk_instruction_t* instr = program->instructions[i];

		GAS_LOG("exporting instruction %x with value %x", instr->type, instr->value.number);
		stackode_instr_to_gas(dest, instr);
	}

	export_gas_footer(dest);

	GAS_LOG("exported all %d instructions", program->count);
}

void export_gas_preamble(FILE* dest) {
	gas_add_comment(dest, "###############################");
	gas_add_comment(dest, "# Generated by heroc compiler  ");
	gas_add_comment(dest, "#                              ");

	fprintf(dest, ".global main \n");
	fprintf(dest, " \n");
	fprintf(dest, ".text \n");
	fprintf(dest, " \n");
	fprintf(dest, "main: \n");

	gas_add_comment(dest, "save the stack frame begin");
	gas_add_instr_2(dest, "movq", gas_reg("sp"), gas_reg("12"));
}

void export_gas_footer(FILE* dest) {

	gas_new_instructiction(dest, "pop value returned from main");
	gas_add_instr_1(dest, "popq", gas_reg("ax"));

	gas_add_comment(dest, "restore original stack pointer");
	gas_add_instr_2(dest, "movq", gas_reg("12"), gas_reg("sp"));

	//TODO exit program?

	gas_add_comment(dest, "#                               ");
	gas_add_comment(dest, "# end of generated code         ");
	gas_add_comment(dest, "############################### ");
}

void stackode_instr_to_gas(FILE* dest, sk_instruction_t* instr) {
	switch (instr->type) {

	case SKI_COMMENT:
		sk_comment_to_gas(dest, instr->value.string);
		break;
	case SKI_LABEL:
		sk_label_to_gas(dest, instr->value.string);
		break;
	case SKI_CALL:
		sk_call_to_gas(dest);
		break;
	case SKI_RETURN:
		sk_return_to_gas(dest);
		break;
	case SKI_CLEANUP_AFTER_CALL:
		sk_cleanup_after_call_to_gas(dest, instr->value.number);
		break;
	case SKI_JUMP_ON_ZERO:
		sk_jump_on_zero_to_gas(dest, instr->value.string);
		break;
	case SKI_JUMP_ON_NON_ZERO:
		sk_jump_on_non_zero_to_gas(dest, instr->value.string);
		break;
	case SKI_JUMP_TO:
		sk_jump_to_to_gas(dest, instr->value.string);
		break;
	case SKI_LOAD:
		sk_load_to_gas(dest);
		break;
	case SKI_ASSIGN:
		sk_assign_to_gas(dest);
		break;
	case SKI_DECLARE_ATOMIC:
		sk_declare_atomic_to_gas(dest);
		break;
	case SKI_DECLARE_ARRAY:
		sk_declare_array_to_gas(dest, instr->value.number);
		break;
	case SKI_PUSH_CONSTANT:
		sk_push_constant_to_gas(dest, instr->value.number);
		break;
	case SKI_PUSH_LABEL_ADRESS:
		sk_push_label_adress_to_gas(dest, instr->value.string);
		break;
	case SKI_PUSH_RELATIVE_ADRESS:
		sk_push_relative_adress_to_gas(dest, instr->value.number);
		break;
	case SKI_PUSH_ABSOLUTE_ADRESS:
		sk_push_absolute_adress_to_gas(dest, instr->value.number);
		break;
	case SKI_POP:
		sk_pop_to_gas(dest);
		break;
	case SKI_DUPLICATE:
		sk_duplicate_to_gas(dest);
		break;
	case SKI_UNARY_OPERATION:
		sk_unary_operation_to_gas(dest, instr->value.number);
		break;
	case SKI_BINARY_OPERATION:
		sk_binary_operation_to_gas(dest, instr->value.number);
		break;
	case SKI_PUSH_CELL_SIZE:
		sk_push_cell_size(dest);
		break;
	case SKI_INVOKE_EXTERNAL:
		sk_invoke_external(dest, instr->value.string, instr->value2.number);
		break;
	case SKI_END:
		sk_end(dest);
		break;
	default:
		fprintf(stderr, "sitg: Unknown stackode instruction %x\n", instr->type);
	}
}

/*****************************************************************************/

void sk_comment_to_gas(FILE* dest, char* comment) {
	gas_new_instructiction(dest, comment);
}

void sk_label_to_gas(FILE* dest, char* label) {
	gas_new_instructiction(dest, "label");
	gas_add_label(dest, label);
}
void sk_call_to_gas(FILE* dest) {
	gas_new_instructiction(dest, "call");

	gas_add_instr_1(dest, "popq", gas_reg("ax"));

	gas_add_instr_1(dest, "pushq", gas_reg("bp"));
	gas_add_instr_2(dest, "movq", gas_reg("sp"), gas_reg("bp"));

	gas_add_instr_1(dest, "call", gas_reg_call("ax"));

	gas_add_instr_1(dest, "popq", gas_reg("bp"));

	gas_add_instr_1(dest, "pushq", gas_reg("ax"));
}

void sk_return_to_gas(FILE* dest) {
	gas_new_instructiction(dest, "return");

	long remove = -1 * CELL_SIZE;

	gas_add_instr_1(dest, "popq", gas_reg("ax"));
	gas_add_instr_2(dest, "movq", gas_reg("bp"), gas_reg("bx"));
	gas_add_instr_2(dest, "addq", gas_num(remove), gas_reg("bx"));
	gas_add_instr_2(dest, "movq", gas_reg("bx"), gas_reg("sp"));

	gas_add_instr_0(dest, "retq");
}

void sk_cleanup_after_call_to_gas(FILE* dest, long params_count) {
	gas_new_instructiction(dest, "cleanup after call");

	long remove = -params_count * CELL_SIZE;
	gas_add_instr_1(dest, "popq", gas_reg("ax"));
	gas_add_instr_2(dest, "subq", gas_num(remove), gas_reg("sp"));
	gas_add_instr_1(dest, "pushq", gas_reg("ax"));
}
void sk_jump_on_non_zero_to_gas(FILE* dest, char* label) {
	gas_new_instructiction(dest, "jump on non zero");

	gas_add_instr_1(dest, "popq", gas_reg("ax"));
	gas_add_instr_2(dest, "cmpq", gas_num(0), gas_reg("ax"));
	gas_add_instr_1(dest, "jne", gas_label(label));
}
void sk_jump_on_zero_to_gas(FILE* dest, char* label) {
	gas_new_instructiction(dest, "jump on zero");

	gas_add_instr_1(dest, "popq", gas_reg("ax"));
	gas_add_instr_2(dest, "cmpq", gas_num(0), gas_reg("ax"));
	gas_add_instr_1(dest, "je", gas_label(label));
}
void sk_jump_to_to_gas(FILE* dest, char* label) {
	gas_new_instructiction(dest, "jump to");

	gas_add_instr_1(dest, "jmp", gas_label(label));
}
void sk_load_to_gas(FILE* dest) {
	gas_new_instructiction(dest, "load");

	gas_add_instr_1(dest, "popq", gas_reg("ax"));
	gas_add_instr_2(dest, "movq", gas_reg_ref(0, "ax"), gas_reg("bx"));
	gas_add_instr_1(dest, "pushq", gas_reg("bx"));
}
void sk_assign_to_gas(FILE* dest) {
	gas_new_instructiction(dest, "assign");

	gas_add_instr_1(dest, "popq", gas_reg("ax"));
	gas_add_instr_2(dest, "movq", gas_reg_ref(0, "sp"), gas_reg("bx")); // +-1 ?
	gas_add_instr_2(dest, "movq", gas_reg("bx"), gas_reg_ref(0, "ax"));
}
void sk_declare_atomic_to_gas(FILE* dest) {
	gas_new_instructiction(dest, "declare atomic");

	gas_add_instr_2(dest, "addq", gas_num(- CELL_SIZE), gas_reg("sp"));
}
void sk_declare_array_to_gas(FILE* dest, long size) {
	gas_new_instructiction(dest, "declare array");

	long inc = -(size * CELL_SIZE);
	gas_add_instr_2(dest, "addq", gas_num(inc), gas_reg("sp"));
}
void sk_push_constant_to_gas(FILE* dest, long value) {
	gas_new_instructiction(dest, "push constant");

	gas_add_instr_1(dest, "pushq", gas_num(value));
}
void sk_push_label_adress_to_gas(FILE* dest, char* label) {
	gas_new_instructiction(dest, "push label of adress");

	gas_add_instr_1(dest, "pushq", gas_label_addr(label));
}
void sk_push_relative_adress_to_gas(FILE* dest, long adress) {
	gas_new_instructiction(dest, "push relative adress");

	long offset;
	if (adress < 0) {
		offset = (-adress - 2) * CELL_SIZE;
	} else {
		offset = (-adress - 1) * CELL_SIZE;
	}
	gas_add_instr_2(dest, "movq", gas_reg("bp"), gas_reg("ax"));
	gas_add_instr_2(dest, "addq", gas_num(offset), gas_reg("ax"));
	gas_add_instr_1(dest, "pushq", gas_reg("ax"));
}
void sk_push_absolute_adress_to_gas(FILE* dest, long adress) {
	gas_new_instructiction(dest, "push absolute adress");

	//+ 1 ? Adress 0 is last cell of previously stack shit
	long offset = -(adress + 1) * CELL_SIZE;
	gas_add_instr_2(dest, "movq", gas_reg("12"), gas_reg("ax"));
	gas_add_instr_2(dest, "addq", gas_num(offset), gas_reg("ax"));
	gas_add_instr_1(dest, "pushq", gas_reg("ax"));

}
void sk_pop_to_gas(FILE* dest) {
	gas_new_instructiction(dest, "pop");

	gas_add_instr_1(dest, "popq", gas_reg("ax"));
}
void sk_duplicate_to_gas(FILE* dest) {
	gas_new_instructiction(dest, "duplicate");

	gas_add_instr_2(dest, "movq", gas_reg_ref(0, "sp"), gas_reg("ax"));
	gas_add_instr_1(dest, "pushq", gas_reg("ax"));
}

void sk_invoke_external(FILE* dest, char* name, long arity) {
	gas_new_instructiction(dest, "invoke external");

	switch (arity) {
	//case 2: move another param into %rsi or where
	case 1: {
		long offset = -((-1) * CELL_SIZE);
		gas_add_instr_2(dest, "movq", gas_reg_ref(offset, "bp"), gas_reg("di"));
	}
		/* no break */
	case 0:
		//nothing to do, hopefully
		break;
	default:
		fprintf(stderr, "sie: Unsupported arity %ld\n", arity);
		return;
	}

	gas_add_instr_1(dest, "jmp", name);

}
void sk_end(FILE* dest) {
	gas_new_instructiction(dest, "That's all folks!");
}
void sk_push_cell_size(FILE* dest) {
	gas_new_instructiction(dest, "push cell size");

	gas_add_instr_1(dest, "pushq", gas_num(CELL_SIZE));
}

void sk_unary_operation_to_gas(FILE* dest, TOKEN_TYPE_T oper) {
	gas_new_instructiction(dest, "unary operation");
	static long not_lbl_uid = 0;

	char* op = NULL;
	TOKEN_TYPE_T op_other = 0;
	switch (oper) {
	case OPT_NOT:
		op_other = OPT_NOT;
		break;
	case OPT_BITWISE_NOT:
		op = "notq";
		break;

	default:
		fprintf(stderr, "suotg1: Unknown unary operator %s\n", to_string(oper));
		return;
	}

	if (op) {
		gas_add_instr_1(dest, "popq", gas_reg("ax"));
		gas_add_instr_1(dest, op, gas_reg("ax"));
		gas_add_instr_1(dest, "pushq", gas_reg("ax"));
	}
	if (op_other) {
		switch (op_other) {
		case OPT_NOT:
			gas_add_instr_1(dest, "popq", gas_reg("ax"));

			char* lbl = generate_label("skip", "not", not_lbl_uid);

			gas_add_instr_2(dest, "mov", gas_num(1), gas_reg("bx"));

			gas_add_instr_2(dest, "cmp", gas_num(0), gas_reg("ax"));
			gas_add_instr_1(dest, "je", gas_label(lbl));

			gas_add_instr_2(dest, "mov", gas_num(0), gas_reg("bx"));
			gas_add_label(dest, lbl);

			gas_add_instr_1(dest, "pushq", gas_reg("bx"));

			not_lbl_uid++;
			break;
		default:
			fprintf(stderr, "suotg2: Unknown unary operator %s\n",
					to_string(oper));
			return;
		}
	}
}
void sk_binary_operation_to_gas(FILE* dest, TOKEN_TYPE_T oper) {
	static long cmp_lbl_uid = 0;

	gas_new_instructiction(dest, "binary operation");

	char* op_basic = NULL;
	char* op_unary = NULL;
	char* op_cmp = NULL;
	TOKEN_TYPE_T op_other = 0;

	switch (oper) {
	case OPT_PLUS:
		op_basic = "addq";
		break;

	case OPT_MINUS:
		op_basic = "subq";
		break;

	case OPT_TIMES:
		op_basic = "imulq";
		break;

	case OPT_DIVIDE:
		op_other = OPT_DIVIDE;
		break;

	case OPT_MODULO:
		op_other = OPT_MODULO;
		break;

	case OPT_SHIFT_LEFT:
		op_unary = "shlq";
		break;

	case OPT_SHIFT_RIGHT:
		op_unary = "shrq";
		break;

	case OPT_BITWISE_AND:
		op_basic = "andq";
		break;

	case OPT_BITWISE_OR:
		op_basic = "orq";
		break;

	case OPT_BITWISE_XOR:
		op_basic = "xorq";
		break;

	case OPT_EQUAL:
		op_cmp = "jz";
		break;

	case OPT_NOT_EQUAL:
		op_cmp = "jnz";
		break;
	case OPT_LESS_THAN:
		op_cmp = "jl";
		break;
	case OPT_LESS_OR_EQUAL:
		op_cmp = "jle";
		break;
	case OPT_GREATER_THAN:
		op_cmp = "jg";
		break;
	case OPT_GREATER_OR_EQUAL:
		op_cmp = "jge";
		break;

	case OPT_INDEX:
		op_other = OPT_INDEX;
		break;

	default:
		fprintf(stderr, "sbotg1: Unknown operator %s\n", to_string(oper));
		return;
	}

	if (op_basic) {
		gas_add_instr_1(dest, "popq", gas_reg("ax"));
		gas_add_instr_1(dest, "popq", gas_reg("bx"));

		gas_add_instr_2(dest, op_basic, gas_reg("ax"), gas_reg("bx"));
		gas_add_instr_1(dest, "pushq", gas_reg("bx"));
	}
	if (op_unary) {
		gas_add_instr_1(dest, "popq", gas_reg("ax"));
		gas_add_instr_1(dest, "popq", gas_reg("bx"));

		gas_add_instr_1(dest, op_unary, gas_reg("bx"));
		gas_add_instr_1(dest, "pushq", gas_reg("bx"));
	}
	if (op_cmp) {
		gas_add_instr_1(dest, "popq", gas_reg("ax"));
		gas_add_instr_1(dest, "popq", gas_reg("bx"));

		char* lbl = generate_label("skip", "cmp", cmp_lbl_uid);

		gas_add_instr_2(dest, "mov", gas_num(1), gas_reg("cx"));

		gas_add_instr_2(dest, "cmp", gas_reg("ax"), gas_reg("bx"));
		gas_add_instr_1(dest, op_cmp, gas_label(lbl));

		gas_add_instr_2(dest, "mov", gas_num(0), gas_reg("cx"));
		gas_add_label(dest, lbl);

		gas_add_instr_1(dest, "pushq", gas_reg("cx"));

		cmp_lbl_uid++;
	}
	if (op_other) {
		switch (op_other) {
		case OPT_INDEX:
			gas_add_instr_1(dest, "popq", gas_reg("ax"));	//offset
			gas_add_instr_1(dest, "popq", gas_reg("bx"));	//base

			gas_add_instr_2(dest, "imulq", gas_num(CELL_SIZE), gas_reg("ax"));
			//gas_add_instr_1(dest, "negq", gas_reg("ax"));

			gas_add_instr_2(dest, "addq", gas_reg("bx"), gas_reg("ax"));
			gas_add_instr_1(dest, "pushq", gas_reg("ax"));
			break;

		case OPT_DIVIDE:
		case OPT_MODULO:
			gas_add_instr_1(dest, "popq", gas_reg("bx"));
			gas_add_instr_1(dest, "popq", gas_reg("ax"));

			gas_add_instr_0(dest, "cdq");
			gas_add_instr_1(dest, "idivq", gas_reg("bx"));

			char* rslt_reg = (op_other == OPT_DIVIDE) ? "ax" : "dx";
			gas_add_instr_1(dest, "pushq", gas_reg(rslt_reg));
			break;

		default:
			fprintf(stderr, "sbotg2: Unknown other operator %s\n",
					to_string(op_other));
			return;
		}
	}
}

/*****************************************************************************/

char* gas_reg(char* name) {
	ALLOC_PRINT_RETURN("%%r%s", name);
	return NULL; //to shut down eclipse warning
}

char* gas_reg_call(char* name) {
	ALLOC_PRINT_RETURN("*%%r%s", name);
	return NULL; //to shut down eclipse warning
}

char* gas_num(long value) {
	ALLOC_PRINT_RETURN("$%ld", value);
	return NULL; //to shut down eclipse warning
}

char* gas_label(char* name) {
	ALLOC_PRINT_RETURN("_%s", name);
	return NULL; //to shut down eclipse warning
}

char* gas_label_addr(char* name) {
	ALLOC_PRINT_RETURN("$_%s", name);
	return NULL; //to shut down eclipse warning
}

char* gas_reg_ref(int offset, char* reg_name) {
	ALLOC_PRINT_RETURN("%d(%%r%s)", offset, reg_name);
	return NULL; //to shut down eclipse warning
}

void gas_new_instructiction(FILE* dest, char* comment) {
	fprintf(dest, "\n");

	//fprintf(dest, "\t nop # (%s) \n", comment);	//debug
	gas_add_comment(dest, comment);
}

void gas_add_instr_0(FILE* dest, char* name) {
	fprintf(dest, "\t %s \t \n", name);
}

void gas_add_instr_1(FILE* dest, char* name, char* arg1) {
	fprintf(dest, "\t %s \t %s \t \n", name, arg1);
}

void gas_add_instr_2(FILE* dest, char* name, char* arg1, char* arg2) {
	fprintf(dest, "\t %s \t %s, \t %s \t \n", name, arg1, arg2);
}

void gas_add_label(FILE* dest, char* label) {
	fprintf(dest, "_%s: \n", label);
}

void gas_add_comment(FILE* dest, char* comment) {
	fprintf(dest, "# %s \n", comment);
}

#endif

